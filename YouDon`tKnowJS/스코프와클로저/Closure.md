## ScopeClosure 스코프 클로저

- 클로저

  - **클로저**는 자바스크립트의 모든 곳에 존재한다.
  - 그저 인식하고 받아들이자. 새롭게 문법과 패턴을 배워야 할 특별한 도구가 아니다.
  - 클로저는 렉시컬 스코프에 의존해 코드를 작성한 결과로 그냥 발생한다.
    이용하려고 굳이 의도적으로 클로저를 생성할 필요도 없다. 모든 코드에서 클로저는 생성되고 사용된다.

- 클로저의 핵심
  - **클로저**는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.

```Javascript

function foo() {
    var a = 2;
    function bar() {
        console.log(a); // 2
    }
    bar();
}
foo();

```

- 함수 bar()는 렉시컬 스코프 검색 규칙을 통해 바깥 스코프의 변수 a에 접근할 수 있다. (RHS 참조 검색)
- 함수 bar()를 설명하는 가장 정확한 방식은 렉시컬 스코프 검색 규칙에 따라 설명하고 이 규칙은 클로저의 일부일 뿐이다.

```Javascript

function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}

var baz = foo();
baz(); // 2

```

- 함수 bar()는 foo()의 렉시컬 스코프에 접근할 수 있고, bar() 함수 자체를 값으로 넘긴다.
  이 코드는 bar를 참조하는 함수 객체 자체를 반환한다.
- foo()를 실행하여 반환한 값(bar() 함수)을 baz라 불리는 변수에 대입하고 실제로는 baz() 함수를 호출했다.
  이는 다른 확인자 참조로 내부 함수인 bar()를 호출한 것이고 bar()함수도 실행됐다.
  그러나 함수 bar는 함수가 선언된 렉시컬 스코프 밖에서 실행됐다.

#### 클로저 관점

- 일반적으로 함수 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각한다. (엔진이 가비지 콜렉터를 사용해 더는 사용하지 않는 메모리를 해제시킨다는 사실 때문)
- 그러나 foo()의 내부 스코프는 여전히 사용 중이므로 메모리가 해제되지 않는다. 그럼 스코프 사용은?
- 바로 bar() 자신이다. 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고, foo()는 bar()가 나중에 참조할 수 있도록 스코프를 살려둔다.
- 즉, bar()는 여전히 해당 스코프에 대한 참조를 가지는데, 이러한 참조를 **클로저**라고 부른다.
- 정리하면 foo() 선언이 끝나고 수 밀리 초 후 변수 baz를 호출할 때, 해당 함수는 원래 코드의 렉시컬 스코프에 접근할 수 있고
  이는 함수가 변수 a에 접근할 수 있다는 의미이다.
- 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다.
  물론 어떤 방식이든 함수를 값으로 넘겨 다른 위치에서 호출하는 행위는 모두 클로저가 작동한 예이다.

```Javascript

function foo() {
    var a = 2;
    function baz() {
        console.log(a) // 2
    }
    bar(baz);
}

function bar(fn) {
    fn();
}

```

- 코드에서 함수 baz를 bar에 넘기고 이제 fn이라는 함수를 호출했다.
- 이 때, foo()의 내부 스코프에 대한 fn의 클로저는 변수 a에 접근할 때 확인할 수 있다.

```Javascript

var fn;

function foo() {
    var a = 2;
    function baz() {
        console.log(a);
    }
    fn = baz; // assign baz to global variable
}

function bar() {
    fn() // look ma, i saw closure
}

foo();

bar(); // 2

```

- 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다.
  어디에서 해당 함수를 실행하든 클로저가 작용한다.
