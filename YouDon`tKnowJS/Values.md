## Values

- 배열

  - 자바스크립트 배열은 문자열, 숫자, 객체, 다른 배열 등 어떤 타입의 값이라도 담을 수 있음
  - 일반적으로 배열에 문자열 타입의 키/프로퍼티는 쓰지 말자, 배열 원소의 인덱스는 확실히 숫자만 쓰자

- 유사배열

  - 숫자 인덱스가 가리키는 값들의 집합

- 특수 값

  - 값 아닌 값 (undefined와 null)
    - null은 빈 값이다 (예전에 값이 있었지만 지금은 없는 상태)
    - undefined는 실종된 값이다. (값을 아직 가지지 않은 것)
  - 숫자
    - 숫자에는 NaN(유효하지 않은 숫자), +Infinity, -Infinity, -0같은 특수 값이 있다.

- 값 VS 레퍼런스
  - 단순 스칼라 원시 값(문자열, 숫자 등)은 값-복사에 의해, 합성 값(객체 등)은 레퍼런스-복사에 의해 값이 할당/전달됨
  - 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념으로 또 다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킴

```Javascript

var a = 2;
var b = a; // b는 언제나 a에서 값을 복사한다.
b++;
a; // 2
b; // 3

var c = [1,2,3];
var d = c; // d는 공유된 [1,2,3]값의 레퍼런스다.
d.push(4);
c; // [1,2,3,4]
d; // [1,2,3,4]

```

- 위 예제코드에서 값 2는 스칼라 원시 값이므로 a에 이 값의 초기 사본이 들어가고, b에는 또 다른 사본이 자리를 잡는다.
  - b를 바꿈으로써 a까지 동시에 값을 변경할 방법이 없다.
- 하지만, c와 d는 모두 합성 값이자 동일한 공유 값 [1,2,3]에 대한 개별 레퍼런스다.

  - 여기서 기억해야 할 점은 c와 d가 [1,2,3]을 '소유'하는 것이 아니라 단지 이 값을 동등하게 참조만 한다는 것
  - 따라서 레퍼런스로 실제 공유한 배열 값이 변경되면, 이 공유 값 한 군데에만 영향을 미치므로 두 레퍼런스는 갱신된 값을 동시에 바라보게 된다.
  - 레퍼런스는 변수가 아닌 값 자체를 가리키므로 A 레퍼런스로 B 레퍼런스가 가리키는 대상을 변경할 수는 없다.

- null, undefined, string, number, boolean, symbol 같은 단순 값(스칼라 원시 값)은 언제나 값-복사
- 객체나(배열과 박싱된 객체 래퍼 전체) 함수 등 합성 값은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.

```Javascript

var a = [1,2,3];
var b = a;
a; // [1,2,3]
b; // [1,2,3]

b = [4,5,6];
a; // [1,2,3]
b; // [4,5,6]
// b = [4,5,6]으로 할당해도 a가 참조하는 [1,2,3]은 영향을 받지 않는다. 그렇게 되려면 b가 배열을 카리키는 레퍼런스가 아닌 포인터가 되어야 하는데, 자바스크립트에는 포인터가 없다.

```

```Javascript
// 함수인자

function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

  x = [4,5,6]
  x.push(7);
  x; // [4,5,6,7]
}

var a = [1,2,3];

foo(a);

a; // [4,5,6,7]이 아닌 [1,2,3,4]

```

- a를 인자로 넘기면 a의 레퍼런스 사본이 x에 할당된다. x와 a는 모두 동일한 [1,2,3]값을 가리키는 별도의 레퍼런스다.
  - 함수 내부에서 이 레퍼런스를 이용하여 값 자체를 변경한다.
  - 하지만 그 후 x = [4,5,6]으로 새 값을 할당해도 초기 레퍼런스 a가 참조하고 있던 값에는 아무런 영향이 없다.
  - 즉, a 레퍼런스는 여전히 [1,2,3,4]값을 바라보고 있다.
  - 레퍼런스 x로 a가 가리키고 있는 값을 바꿀 도리는 없다. 다만 a와 x 둘 다 가리키는 공유 값의 내용만 바꿀 수 있다.
  - 배열을 새로 생성하여 할당하는 식으로는 a의 내용을 [4,5,6,7]로 바꿀 수 없다. 기존에 존재하는 배열 값만 변경해야 한다.

```Javascript
function foo(x) {
  x.push(4);
  x; // [1,2,3,4]

x.length = 0;
x.push(4,5,6,7);
x; // [4,5,6,7]
}

var a = [1,2,3];

foo(a);

a; // [1,2,3,4]가 아닌 [4,5,6,7]

foo(a.slice());
/* 인자 없이 slice()를 호출하면 전혀 새로운 배열의(얕은 복사 shallow copy) 사본을 만든다.
   이렇게 사본만을 가리키는 레퍼런스를 전달하니 foo()는 a의 내용을 건드릴 수 없다. */
```

- x.length = 0, x.push(4,5,6,7)은 새 배열을 생성하는 코드가 아니라, 이미 두 변수가 공유한 배열을 변경하는 코드이므로 a는 새로운 값 [4,5,6,7]을 가리킨다.
  - 값-복사냐, 레퍼런스-복사냐 우리가 마음대로 결정할 수 없다. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.
  - (배열같은) 함성 값을 값-복사에 의해 효과적으로 전달하려면 손수 값의 사본을 만들어 전달한 레퍼런스가 원본을 가리키지 않게 하면 된다.

```Javascript
function foo(wrapper) {
  wrapper.a = 42;
}

var obj = {
  a: 2
};
foo(obj);
obj.a; // 42

```

- 반대로 스칼라 원시 값을 레퍼런스처럼 바뀐 값이 바로바로 반영되도록 넘기려면 원시 값을 다른 합성 값(객체, 배열 등)으로 감싸야한다.
  - obj는 스칼라 원시 프로퍼티 a를 감싼 래퍼로 foo() 함수에 obj 레퍼런스 사본이 전달되고 래퍼 인자의 값을 바꾼다.
  - 이제 래퍼 레퍼런스로 공유된 객체에 접근하여 프로퍼티를 수정할 수 있다. 함수 종료 obj.a의 값 42

```Javascript
function foo(x) {
  x = x + 1;
  x; // 3
}

var a = 2;
var b = new Number(a); // Object(a)도 같은 표현

foo(b);
console.log(b); // 2
/* 표현식 x + 1에서 x가 사용될 때 내부에 간직된 스칼라 원시 값 2는 Number 객체에서 자동언박싱(추츨)된다.
   x = x + 1의 x는 공유된 레퍼런스에서 Number객체로 뒤바뀌고 2 + 1 덧셈 결과인 스칼라 원시 값 3을 갖게 된다.
   따라서 바깥의 b는 원시 값 2를 씌운, 변경되지 않은/불변의 원본 Number 객체를 참조한다. */
```

- 같은 원리로 2와 같은 스칼라 원시 값을 레퍼런스 형태로 넘기려면 Number 객체 레퍼로 원시 값을 박싱하면 된다.
  - Number 객체의 레퍼런스 사본이 함수에 전달되는 것은 맞지만 공유된 객체를 가리키고 있는 레퍼런스가 있다고 자동으로 공유된 원시 값을 변경할 권한은 없다.
  - 내부의 스칼라 원시 값이 불변이다 (문자열, 불리언도 마찬가지)
  - 스칼라 원시 값 2를 가진 Number 객체가 있다면, 이와 동일한 객체가 다른 원시 값을 가지도록 변경할 수 없다.
  - 다른 값을 넣은, 완전히 별개의 Number 객체를 생성할 수는 있다.
  - Number 객체에 (내부 원시 값 변경이 아니라) 프로퍼티를 추가하고 간적접이나마 추가된 프로퍼티를 통하여 정보를 교환할 수는 있다. (그러나 좋은 습관은 아님)
  - 이렇게 객체 래퍼를 사용하기보단 차라리 처음부터 손수 객체 래퍼(obj)를 쓰는게 훨씬 낫다. (대부분의 경우 스칼라 원시 값을 사용하는 것이 좋음)

### 값-복사냐 레퍼런스-복사냐 결정하는 유일한 단서는 값의 타입뿐이므로 사용할 값 타입을 잘 정해서 간접적으로 할당/전달 로직에 반영해야 한다.
