# Promise

- 귀결: 최후에 다다르는 것, 또는 그 결론이나 결과

### 콜백의 문제

- 콜백으로 프로그램의 비동기성을 표현하고 동시성을 다루면 순차성과 믿음성이 결여되는 중요한 결함이 있다.
- 먼제 제어의 역전, 허술하게 매달려 있다가 쉽게 소실되는 믿음의 문제
  - 프로그램의 연속 실행을 감싼 콜백 함수를 다른 곳(ex: 서드 파티)에 전달하면 별 탈 없이 정상적으로 콜백이 되길 기도하는 수 밖에 없다.
- 그러나 만일 제어의 역전을 되역전시킬 수 있다면?
  - 프로그램의 진행을 다른파트에 넘겨주지 않고 개발자가 언제 작업이 끝날지 알 수 있고, 그 다음에 무슨 일을 해야 할지 스스로 결정할 수 있다면?
- **이러한 체계가 프라미스다.**

### Promise?

- 시나리오를 짜보자
- 미랫값

  1. 햄버거집에 가 치즈 버거 세트를 먹기로 하고, 점원에게 주문을 한 뒤 5500원을 결제한다. (동시에 거래가 시작)
  2. 주문이 밀리면 치즈 버거가 바로 안나올 수 있다. 점원은 주문 번호를 주고 언젠가 반드시 치즈 버거를 주겠다는 **프라미스**다.
  3. 아직 받지 못한 치즈 버거가 눈앞에 있는 양 사고한다. 내 두뇌는 이미 영수증에 적힌 주문 번호를 치즈 버거의 자리 끼움으로 인식하고 이 끼움은 독립적인 값, 미랫값이다.
  4. 이후, 점원이 부른 내 번호의 영수증을 돌려주고 치즈 버거 세트를 받는다. 즉, 나의 미랫값이 준비되어 갖고 있던 값-프라미스를 값 자체와 교환한 셈이다.
  5. 물론, 다시 확인해보니 재료가 다 떨어졌네요라고 말을 한다. 미랫값은 성공 아니면 실패라는 중요한 깨달음이 있다.

- 지금값과 나중값

```Javascript
  var x, y = 2;
  console.log(x + y); // NaN <-- 'x'는 아직 세팅 전이다.
```

- x + y 연산을 할 땐 당연히 x, y 모두 이미 세팅된 값이라고 본다. 위 상태의 x, y 값은 이미 '귀결됐다(resolved)'라고 할 수 있다.
- - 연산자가 x, y 값의 상태를 감지하다가 모두 귀결된(준비된) 후 덧셈 연산을 해주리라 기대하는 건 무리다.
- 상이한 문(statement) 중 어떤 문은 '지금' 실행되고 다른 문은 '나중'에 실행되면 프로그램이 혼돈의 늪에 빠지고 만다.
- 지금과 나중을 모두 일관적으로 다루려면 둘 다 나중으로 만들어 모든 작업을 비동기화하면 된다.

- 프라미스 값

```Javascript
  function add (xPromise, yPromise) {
      // Promise.all([])은 프라미스 배열을 인자로 받아 프라미스들이 모두 귀결될 때까지 기다렸다가 새 프라미스를 만들어 반환하는 함수다.
      return Promise.all([xPromise, yPromise])

      // 프라미스가 귀결되면 x와 y의 값을 받아 더한다.
      .then(function (valuse) {
          // values는 앞에서 귀결된 프라미스가 건네준 메시지 배열이다.
          return values[0] + values[1];
      });
  }

  // fetchX()와 fetchY()는 제각기 값을 가진 프라미스를 반환하는데, 지금 또는 나중에 준비된다.
  add(fetchX(), fetchY());

  // 두 숫자의 합이 담긴 프라미스를 받고 반환된 프라미스가 귀결될 때까지 대기하기 위해 then()을 연쇄 호출한다.
  .then(function (sum) {
      console.log(sum);
  });
```

- 이 예제에는 두 계층의 프라미스가 있다.
  1. fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값(프라미스!)을 add()에 전달한다.
  2. add()가 (Promise.all([])를 거쳐) 만들어 반환한 프라미스로 then()을 호출하고 대기한다.
- 치즈 버거 세트 주문처럼 프라미스는 이룸(Fullfillment, 이행) or 버림(Rejection)으로 귀결될 수 있다.
- 여기서 이룸과 버림은 성공과 실패로 쉽게 번역한 도서도 있지만 원어의 사전적 의미와 미묘한 기술적 콘텍스트를 감안할 때, 이룸, 버림쪽이 더 가깝다.
- 항상 귀결 값을 프로그램이 결정짓는 이룸 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 한다.
- 프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받는다.

```Javascript
  add (fetchX(), fetchY())
  .then(
      // 이룸 함수
      function(sum) {
          console.log(sum)
      },
      // 버림 함수
      function(err) {
          console.log(err)
      }
  )
```

- X나 Y 조회 시 문제가 있거나 덧셈 연산이 실패하면 add()가 반환하는 프라미스는 버려지고 then()의 두 번째 에러 처리 콜백이 이 프라미스에서 버림값을 받는다.
- 프라미스는 시간 의존적인 상태를 외부로부터 캡슐화(원래 값을 이룰지 버릴지 기다림)하기 때문에
  프라미스 자체는 시간 독립적이고 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있다.
- 또한 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며(귀결 시점에 불변값이 된다.)몇 번이든 필요할 때마다 꺼내 쓸 수 있다.
  (프라미스는 귀결되고 나면 불변 상태이므로 악의적으로 변경되는 일 없이 다른 파트에 전달 가능)

#### 불변성은 프라미스를 제대로 알려면 반드시 이해해야 할, 강력하고 중요한 개념이다.

### 완료 이벤트

- 프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 '흐름 제어'하기 위한 체계라 볼 수 있다.
- 어떤 작업을 하려고 foo() 함수를 부른다고 치자. 작업 내용, 걸리는 시간 등 여러 사항이 있다.
- 그러나 우리는 단지 foo()가 언제 끝나 다음 단계로 넘아갈 수 있을지만 알면 된다. 다음 단계로 진행할 수 있게끔 foo()의 완료 상태를 받을 방법이 있으면 좋겠다.

```Javascript
  foo(x) {
    // 뭔가 일을 시작
  }
  foo(42)

  on (foo "완료") {
    // 다음 단계
  }
  on (foo "에러") {
    // 에러 발생
  }

```

- foo()를 부른 뒤, 2개의(완료, 에러 이벤트를 각각 리스닝하는) 이벤트 리스너를 설정한다.
- foo()를 호출하여 나올 수 있는 결과는 완료 아니면 에러뿐이다. 실상 foo()는 호출부에서 이벤트를 받아 어떻게 처리할지 알 길이 없으니 관심사가 분리된다.

```Javascript

  function foo(x) {
    // 일 시작
    // 이벤트 구독기를 생성하여 반환
    return listener;
  }
  let evt = foo(42);

  evt.on("completion", function() {
    // 다음 단계
  });
  evt.on("failure", function(err) {
    // 에러 발생
  });

```

- foo()는 이벤트 구독기를 생성하여 반환하도록 명시되어 있고 여기에 호출부 코드는 두 이벤트 처리기를 각각 등록한다.
- foo()에 콜백 함수를 넘겨주는 대신 foo()가 evt라는 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣는다.
- 콜백에서는는 그 자신이 제어의 역전이라고 했다. 따라서 콜백 패턴을 뒤집는다는 건 역전을 역전, 제어의 되역전이고 우리가 바라던 대로 제어권을 호출부에 되돌려놓게 된다.
- 이렇게 되면 여러파트로 나뉘어진 코드가 이벤트를 리스닝하면서 foo() 완료 시 독립적으로 알림을 받아 이후 단계를 진행하게 된다.

```Javascript
    let evt = foo(42);

    // bar()는 foo()의 완료 이벤트를 리스닝한다.
    bar(evt);

    // baz()는 foo()의 완료 이벤트를 리스닝한다.
    baz(evt);

```

- 제어의 비역전 덕분에 bar(), baz()는 foo() 호출에 끼어들 이유가 없다.
- 결국 evt 객체가 분리된 관심시 간의 중립적인 중재자 역할을 수행하는 것

### 프라미스 '이벤트'

```Javascript
  function foo(x) {
    // 작업 시작
    // 프라미스를 생성하여 반환
    return new Promise(function(resolve, reject) {
      // 결과적으로 'resolve()', 'reject()' 중 한쪽을 호출하게 되고 이들은 프라미스의 귀결 콜백 함수 역할을 한다.
    });
  }
  var p = foo(42);
  bar(p);

  baz(p);

```

- new Promise(function() { })는 '생성자 노출 패턴의 전형적인 모습이다.'
- 전달된 function은 즉시 실행되고 resolve, reject라는 인자 2개를 받는다.
- 이 두 인자가 바로 프라미스의 귀결 함수다. resolve()는 이룸을, reject()는 버림을 나타낸다.

```Javascript
  function foo(fooPromise) {
    // foo()의 완료 여부를 리스닝한다.
    fooPromise.then (
      function() {
        // foo()는 이제 bar() 작업을 한다.
      },
      function() {
        // foo()에서 뭔가 잘못됐다
      }
    );
  }
  // baz()도 마찬가지

```

- 프라미스를 미랫값으로 다루었을 때처럼 프라미스 귀결 시 어떤 메시지를 보내야 하는 건 아니다. 단지 흐름 제어 신호로 쓰일 수 있다.

```Javascript
  function bar() {
    // foo()는 확실히 끝났으므로 bar() 작업을 한다.
  }

  function oopsBar() {
    // foo()에서 뭔가 잘못되어 bar()는 실행되지 않는다.
  }

  // baz()와 oopsBaz()도 마찬가지
  var p = foo(42);
  p.then(bar, oopsBar);
  p.then(baz, oopsBaz);
```

- 프라미스 p를 bar(), baz()에 태워 보내는 대신 두 함수의 실행 이후를 제어하기 위해 프라미스를 이용한다.
- 앞 예제와의 가장 큰 차이점은 에러 처리 방식이다.
- 전자는 foo()의 이룸/버림 여부와 관계없이 무조건 bar()를 호출하고 foo()실행이 실패 할 경우엔 자체 로직으로 처리한다.
- 후자는 foo() 성공 시에만 bar()를 호출하고 그 외엔 oopsBar()함수를 호출한다.
- 어느 쪽이 절대 옳다고 할 수는 없으며, 상황에 따라 적잘한 방식을 선택하면 된다.
- 중요한 점은 foo()가 반환한 프라미스 p로 다음에 벌어질 일을 제어할 수 있다.
- 또한 두 예제 모두 같은 프라미스 p에 대해 then()을 두 번 호출하는 부분에서, 프라미스는 똑같은 결과를 영원히 유지하므로 이후에 계속 꺼내 쓸 수 있음을 알 수 있다.
