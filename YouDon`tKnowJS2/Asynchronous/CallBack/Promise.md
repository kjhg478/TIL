# Promise

- 귀결: 최후에 다다르는 것, 또는 그 결론이나 결과

- 콜백의 문제

  - 콜백으로 프로그램의 비동기성을 표현하고 동시성을 다루면 순차성과 믿음성이 결여되는 중요한 결함이 있다.
  - 먼제 제어의 역전, 허술하게 매달려 있다가 쉽게 소실되는 믿음의 문제
    - 프로그램의 연속 실행을 감싼 콜백 함수를 다른 곳(ex: 서드 파티)에 전달하면 별 탈 없이 정상적으로 콜백이 되길 기도하는 수 밖에 없다.
  - 그러나 만일 제어의 역전을 되역전시킬 수 있다면?
    - 프로그램의 진행을 다른파트에 넘겨주지 않고 개발자가 언제 작업이 끝날지 알 수 있고, 그 다음에 무슨 일을 해야 할지 스스로 결정할 수 있다면?
  - **이러한 체계가 프라미스다.**

- Promise?

  - 시나리오를 짜보자
  - 미랫값

    1. 햄버거집에 가 치즈 버거 세트를 먹기로 하고, 점원에게 주문을 한 뒤 5500원을 결제한다. (동시에 거래가 시작)
    2. 주문이 밀리면 치즈 버거가 바로 안나올 수 있다. 점원은 주문 번호를 주고 언젠가 반드시 치즈 버거를 주겠다는 **프라미스**다.
    3. 아직 받지 못한 치즈 버거가 눈앞에 있는 양 사고한다. 내 두뇌는 이미 영수증에 적힌 주문 번호를 치즈 버거의 자리 끼움으로 인식하고 이 끼움은 독립적인 값, 미랫값이다.
    4. 이후, 점원이 부른 내 번호의 영수증을 돌려주고 치즈 버거 세트를 받는다. 즉, 나의 미랫값이 준비되어 갖고 있던 값-프라미스를 값 자체와 교환한 셈이다.
    5. 물론, 다시 확인해보니 재료가 다 떨어졌네요라고 말을 한다. 미랫값은 성공 아니면 실패라는 중요한 깨달음이 있다.

  - 지금값과 나중값

  ```Javascript
    var x, y = 2;
    console.log(x + y); // NaN <-- 'x'는 아직 세팅 전이다.
  ```

  - x + y 연산을 할 땐 당연히 x, y 모두 이미 세팅된 값이라고 본다. 위 상태의 x, y 값은 이미 '귀결됐다(resolved)'라고 할 수 있다.
  - - 연산자가 x, y 값의 상태를 감지하다가 모두 귀결된(준비된) 후 덧셈 연산을 해주리라 기대하는 건 무리다.
  - 상이한 문(statement) 중 어떤 문은 '지금' 실행되고 다른 문은 '나중'에 실행되면 프로그램이 혼돈의 늪에 빠지고 만다.
  - 지금과 나중을 모두 일관적으로 다루려면 둘 다 나중으로 만들어 모든 작업을 비동기화하면 된다.

  - 프라미스 값

  ```Javascript
    function add (xPromise, yPromise) {
        // Promise.all([])은 프라미스 배열을 인자로 받아 프라미스들이 모두 귀결될 때까지 기다렸다가 새 프라미스를 만들어 반환하는 함수다.
        return Promise.all([xPromise, yPromise])

        // 프라미스가 귀결되면 x와 y의 값을 받아 더한다.
        .then(function (valuse) {
            // values는 앞에서 귀결된 프라미스가 건네준 메시지 배열이다.
            return values[0] + values[1];
        });
    }

    // fetchX()와 fetchY()는 제각기 값을 가진 프라미스를 반환하는데, 지금 또는 나중에 준비된다.
    add(fetchX(), fetchY());

    // 두 숫자의 합이 담긴 프라미스를 받고 반환된 프라미스가 귀결될 때까지 대기하기 위해 then()을 연쇄 호출한다.
    .then(function (sum) {
        console.log(sum);
    });
  ```

  - 이 예제에는 두 계층의 프라미스가 있다.
    1. fetchX()와 fetchY()를 직접 호출하여 이들의 반환 값(프라미스!)을 add()에 전달한다.
    2. add()가 (Promise.all([])를 거쳐) 만들어 반환한 프라미스로 then()을 호출하고 대기한다.
  - 치즈 버거 세트 주문처럼 프라미스는 이룸(Fullfillment, 이행) or 버림(Rejection)으로 귀결될 수 있다.
  - 여기서 이룸과 버림은 성공과 실패로 쉽게 번역한 도서도 있지만 원어의 사전적 의미와 미묘한 기술적 콘텍스트를 감안할 때, 이룸, 버림쪽이 더 가깝다.
  - 항상 귀결 값을 프로그램이 결정짓는 이룸 프라미스와는 다르게 버림값은 프로그램 로직에 따라 직접 세팅되거나 런타임 예외에 의해 암시적으로 생겨나기도 한다.
  - 프라미스 then() 함수는 이룸 함수를 첫 번째 인자로, 버림 함수를 두 번째 인자로 각각 넘겨받는다.

  ```Javascript
    add (fetchX(), fetchY())
    .then(
        // 이룸 함수
        function(sum) {
            console.log(sum)
        },
        // 버림 함수
        function(err) {
            console.log(err)
        }
    )
  ```

  - X나 Y 조회 시 문제가 있거나 덧셈 연산이 실패하면 add()가 반환하는 프라미스는 버려지고 then()의 두 번째 에러 처리 콜백이 이 프라미스에서 버림값을 받는다.
  - 프라미스는 시간 의존적인 상태를 외부로부터 캡슐화(원래 값을 이룰지 버릴지 기다림)하기 때문에
    프라미스 자체는 시간 독립적이고 타이밍 또는 내부 결괏값에 상관없이 예측 가능한 방향으로 구성할 수 있다.
  - 또한 프라미스는 일단 귀결된 후에는 상태가 그대로 유지되며(귀결 시점에 불변값이 된다.)몇 번이든 필요할 때마다 꺼내 쓸 수 있다.
    (프라미스는 귀결되고 나면 불변 상태이므로 악의적으로 변경되는 일 없이 다른 파트에 전달 가능)

  #### 불변성은 프라미스를 제대로 알려면 반드시 이해해야 할, 강력하고 중요한 개념이다.
