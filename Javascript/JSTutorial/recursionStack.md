# 재귀와 스택

- 재귀

  - 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴
  - 문제 해결을 하다보면 함수에서 다른 함수를 호출해야 할 때가 있습니다. 이 때 함수가 자기 자신을 호출할 수도 있는데 이를 재귀라 부릅니다.

  ```Javascript
      pow(2, 2) = 4
      pow(2, 3) = 8
      pow(2, 4) = 16

      // way 1
      function pow(x, n) {
      let result = 1;

      // 반복문을 돌면서 x를 n번 곱함
      for (let i = 0; i < n; i++) {
          result *= x;
      }

      return result;
      }

      alert( pow(2, 3) ); // 8

      // way 2
      function pow(x, n) {
      if (n == 1) {
          return x;
      } else {
          return x * pow(x, n - 1);
      }
      }

      alert( pow(2, 3) ); // 8
  ```

- 실행 컨텍스트와 스택

  - 실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(Execution context)에 저장됩니다.
  - 실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조입니다. 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장됩니다.

- 연결 리스트

  - 객체를 정렬하여 어딘가 저장하고 싶을 때 가장 먼저 떠오르는 자료 구조는 배열일 겁니다.
  - 그러나 배열은 요소 '삭제'와 '삽입'에 들어가는 비용이 많이 든다는 문제가 있습니다.
    arr.unshift(obj) 연산을 수행하려면 새로운 obj를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매깁니다.
    배열이 커지면 연산 수행 시간이 더 걸리게 됩니다. arr.shift()를 사용할 때도 마찬가지입니다.
  - 요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 arr.push/pop 뿐이죠
  - 빠르게 삽입 혹은 삭제를 해야 할 때는 배열 대신 **연결 리스트(Linked list)**라 불리는 자료 구조를 사용할 수 있습니다.

    1. value
    2. next: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null이 됩니다.

    ```Javascript
        let list = {
            value: 1,
            next: {
                value: 2,
                next: {
                    value: 3,
                    next: {
                        value: 4,
                        next: null
                    }
                }
            }
        };

        // 연결 리스트로 여러 부분으로 나누고, 합치는 것도 가능
        let secondList = list.next.next;
        list.next.next = null;

        // 합치기
        list.next.next = secondList;

        // 요소 추가
        let list = { value: 1 };
        list.next = { value: 2 };
        list.next.next = { value: 3 };
        list.next.next.next = { value: 4 };

        // list에 새로운 value를 추가합니다.
        list = { value: "new item", next: list };
        // 중간 요소를 제거하려면 이전 요소의 next를 변경
        list.next = list.next.next;
    ```

    - 연결 리스트가 항상 배열보다는 우월하지는 않습니다.
    - 연결 리스트의 가장 큰 단점은 번호(인덱스)만 사용해 요소에 쉽게 접근할 수 없다는 점입니다.
    - 배열을 사용하면 arr[n]처럼 번호 n만으로 원하는 요소에 바로 접근할 수 있지만 연결 리스트에선 N번째 값을 얻기 위해 첫 번째 항목부터 시작해 N번 next로 이동해야 합니다.

### 정리하기

    - 재귀
        - 함수 내부에서 자기 자신을 호출하는 것을 나타내는 프로그래밍 용어.
        - 재귀 함수는 우아하게 원하는 문제를 해결할 때 자주 쓰이곤 합니다.
        - 함수가 자신을 호출하는 단계를 재귀 단계라고 부릅니다.
    - 재귀적으로 정의된 자료구조는 자기 자신을 이용해 자료 구조를 정의합니다.
        - 재귀적으로 정의된 자료구조에 속하는 연결 리스트는 리스트 혹은 null을 참조하는 객체로 이루어진 데이터 구조를 사용해 정의됩니다.
