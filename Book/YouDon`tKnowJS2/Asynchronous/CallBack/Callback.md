# 콜백

## 비동기성: 지금과 나중 정리

- 지금과 나중에서는 자바스크립트 비동기 프로그래밍의 용어와 개념 그리고 모든 이벤트(비동기 함수 호출)를 관장하는,
  단일-스레드(한 번에 하나씩) 방식의 이벤트 루프 큐에 대해 살펴봤다.
- 또한 동시에 실행되는 여러 이벤트 또는 "프로세스" (작업, 함수 호출 등) 연쇄 간의 관계를 설명하는 여러 가지 동시성 패턴에 대해서도 알아봤다.
- 예제 코드들의 모든 함수는 더는 나뉘지 않는 개별적인 실행 단위로,
  함수 안의 문을 예측 가능한 순서대로 실행되지만 함수 단위의 실행 순서는 이벤트(비동기 함수 호출)에 따라 달라질 수 있다.

### 콜백

- 어떤 경우든 함수는 **콜백** 역할을 한다. 큐에서 대기 중인 코드가 처리되자마자 본 프로그램으로 되돌아올 목적지기 때문이다.
- 콜백은 자바스크립트에서 비동기성을 표현하고 관리하는 가장 일반적인 기법이자, 가장 기본적인 비동기 패턴이다.
- 그러나 콜백에도 단점은 조재하고 더 나은 비동기 패턴이 나오게 된다.
  그런데 무엇을, 왜 추상화 하는지 모르고서는 그 결과물을 효과적으로 활용할 수 없다.
- 콜백의 실체를 깊이 있게 살펴보고 더 정교한 비동기 패턴이 나오게 된 계기에 대해 알아보자 !

### 연속성

```Javascript
  // A
  ajax("..", function(..) {
    // C
  });
  // B
```

- A와 B는 프로그램 전반부(지금), C는 프로그램 후반부(니중)에 각각 해당한다.
- 전반부 코드가 실행되면 비결정적 시간 동안 중지되고 언젠가 AJAX 호출이 끝날 때 중지되기 이전 위치로 다시 돌아와 후반부 프로그램이 이어진다.
- 즉, 콜백 함수는 프로그램의 연속성을 감싼/캡슐화 한 장치다.

```Javascript
  // A
  setTimeout(function() {
    // C
  }, 1000);
  // B
```

- 실행 과정
  - A를 실행한 다음 1,000밀리 초 타임아웃을 설정하고 B를 실행하고 타임아웃 시, C를 실행한다.
  - 사람의 머릿속에서 돌아가는 코드와 자바스크립트 엔진이 실제로 실행하는 코드를 잘 맞추어 설명하기란 어렵다.
  - 이렇게 미묘하고 엄청난 단절을 느끼자 ! 그래야 비동기를 표현/관리하는 콜백의 결점을 납득할 수 있다.

### 중첩/연쇄된 콜백

```Javascript
  listen('click', function handler(evt) {
    setTimeout(function request() {
      ajax("http://...", function response(text) {
        if (text == "hello") {
          handler();
        } else if (text == "world") {
          request();
        }
      });
    }, 500);
  });

```

- 비동기 단계를 3개의 함수가 서로 중첩된 형태로 표현되었다.
- 콜백 지옥 또는 운명의 피라미드라고도 불리는 코드다.
- 자 우선, 클릭 이벤트 대기 -> 타이머 작동까지 대기 -> AJAX 응답을 받을 때까지 대기순으로 진행하고 처음부터 되풀이된다.

- 그러면 중첩 없이 이벤트/타임아웃/AJAX 예제를 다시 써보자.

```Javascript
  listen("click", handler);

  function handler() {
    setTimeout(request, 500);
  }

  function request() {
    ajax("http://..", response);
  }

  function response(text) {
    if (text == "hello") {
      handler();
    } else if (text == "world") {
      request();
    }
  }

```

- 알아보기는 훨씬 편하지만 콜백 지옥에 취약한건 같다.
- 선형적(순차적)으로 코드를 추론하면 한 함수에서 다음 함수로, 또 그다음 함수로, 시퀀스 흐름을 "따라가기" 위해 코드 베이스 전체를 널뛰기 해야 한다.
- 그러나 이 예제의 경우 단순한 코드지만, 실무에서는 비동기 자바스크립트 코드는 뒤죽박죽 뒤섞여 있고, 추론의 어려움은 차원이 다르다.

- 이렇게 콜백은 대부분 바람직하지 않으며, 만일의 사태와 가능한 경우의 수를 죄다 나열하며 하드 코딩식으로 했다간 코드가 너무 복잡해져 버려 관리 및 수정이 난처해진다.
- 이것이 **콜백 지옥**이다. 여기서 끝나지 않고, 복수의 연속된 콜백이 서로 연쇄된 상태로 동시 발생하거나, 관문이나 병렬 콜백으로 분기하는 단계도 있다.
- 사람의 두뇌가 순차적으로 중단을 일으키며 계획하는 방식이 콜백 지향의 비동기 코드와 잘 맞지 않는다는 사실이 확실히 드러난다.
- 이것이 콜백의 중요한 첫 번째 단점이다.

### 정리하기

- 콜백은 자바스크립트에서 비동기성을 표현하는 기본 단위다.
- 그러나 자바스크립트와 더불어 점점 진화하는 비동기 프로그래밍 환경에서 콜백만으로는 충분하지 않다.

1. 콜백의 방식

   - 사람의 두뇌는 순차적, 중단적, 단일-스레드 방식으로 계획하는데 익숙하지만 콜백은 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내므로
     구현된 코드를 제대로 이해하기가 매우 어려우며, 추론하기 곤란한 코드는 예상치 못한 버그를 품을 수 있는 나쁜 코드로 이어진다.
   - 비동기성을 좀 더 동기적, 순차적, 중단적인 모습으로, 우리 두뇌가 사고하는 방식과 유사하게 표현할 방법이 필요하다.

2. 콜백의 제어권

   - 콜백은 프로그램을 진행하기 위해 제어를 역전, 제어권을 다른 파트(서드 파티 등)에 암시적으로 넘겨줘야 하므로 골치가 아프다.
   - 이렇게 제어권이 넘어가게 되면 예상보다 더 자주 콜백을 호출하는 등 여러 가지 믿음성 문제에 봉착하게 된다.
   - 믿음성 문제를 해결하고자 임시 로직을 짜 넣으면 당장은 난관을 모면할 순 있지만 생각만큼 구현하기도 쉽지 않고 계속 그렇게 하다보면 유지보수가 어려운 코드로 변질된다.
   - 추가로 버그가 발견되어 막대한 피해로부터 보호받을 방법또한 없다.

- 아무래도 콜백을 능가하는 뭔가가 필요하다.
- 지금까지 콜백은 임무를 훌륭히 잘 수행해왔지만 미래의 자바스크립트 환경에서는 더욱 정교하고 역량 있는 비동기 패턴이 필요하다.
